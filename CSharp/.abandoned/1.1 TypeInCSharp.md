
事实上除了`int`和`double`之外，其他的数字类型也与C语言有相同也有不同的地方。

| C#       | C语言（64位Windows） | 含义                                                         |
| -------- | -------------------- | ------------------------------------------------------------ |
| `int`    | `int`                | 32位有符号整型                                               |
| `short`  | `short`              | 16位有符号整型                                               |
| `long`   | `long long`          | 64位有符号整型                                               |
| `float`  | `float`              | 32位单精度浮点数                                                 |
| `double` | `double`             | 64位双精度浮点数                                                 |
| `sbyte`  | `char`               | 8位有符号整型，在C语言中表示ASCII字符                        |
| `byte`   | `unsigned char`      | 8位无符号整型                                                |
| `char`   | `wchar_t`            | 字符，C\#中所有的字符都是C语言中的宽字符，单个字符可储存一个汉字 |
| `uint`   | `unsigned int`       | 32位无符号整型                                               |
| `bool`   | `bool`               | 布尔类型（true和false），C语言中需要包含头文件`stdbool.h`才能使用           |

> 在C语言中，数值类型的宽度与平台息息相关，但是在C\#中，相同的数值类型的宽度永远是恒定的。

> 思考：已知32位有符号整型叫`int`，32位无符号整型叫`unit`，64位有符号整型叫做`long`，那么64位有符号整型应该叫做什么？

> 在C语言中，`char*`和`char[]`并不能算是类型，因为仅有`char *a,*b,c[3];`才是合法的
> 但是C#中的`char*`和`char[]`都是单独的类型，不考虑var的使用，上面一句能且仅能转换为如下两句：
> ```C#
> char* a,b;
> char[] c;
> ```
> C#的数组声明时不能指定大小，因为声明时并没有为数组分配任何内存空间。

你不需要关注这一行是不是太长了，只要你调用`Console.ReadLine`，一切都会帮你处理好。

你这里可能会注意到，C#中并没有与`scanf`作用相同的函数，`Console.ReadLine`的功能反而与C语言中的`gets`相似，这是因为`scanf`中需要使用指针传递变量，而C\#中是不鼓励使用指针的。

> 思考：C\#中不鼓励使用指针，那么在C\#中遇到C语言中使用指针的场景应该怎么办呢？

C\#也能像C语言一样，能够使用括号进行类型转换，如：

``` csharp
double d = 1.0;
int i = (int)d; //合法，double能强制转换成int，规则与C语言一样是向下取整
```

也遵循C语言中的部分隐式类型转换规则，但是有所不同，如：

``` csharp
int a = 10;

long b = a; //合法，短的整型能够装到长的里面
int c = b; //不合法，长的整型不能装到短的里面

uint d = 10; //合法，虽然没有用u结尾，但是字面量能进行隐式类型转换
uint e = a; //不合法，虽然总位数相同，但是int的最高位被用于储存符号信息，因此有符号整型和无符号整型不能相互隐式转换

ulong f = a; //不合法，就转换到的算位数更多，有符号整型和无符号整型之间也不能相互隐式转换，因为无符号整型不能表示负数
uint g = (uint)a; //合法，有无符号的转换需要使用强制转换，但是如果转换出现了溢出C#默认会报错

ulong h = d; //合法，无符号的同上
uint i = e; //不合法，无符号的同上

double j = a; //合法，整型能隐式类型转换到浮点型

string k = "10";
int l = (int)k; //不合法，强制类型转换不适用于string

char m = 'a'; //合法，char就是这么赋值的
int n = m; //合法，char在C#中是16位的
sbyte o = m; //不合法，char在C#中是16位的
char p = 97; //不合法，即使97是a的ASCII码，char类型也不能由整型隐式类型转换
char q = (char)97; //合法，整型转到字符型需要使用强制类型转换
```

我们可以看到，`string`类型无法通过加括号的方法进行强制类型转换。但是

>除了Convert，xxx.Parse也可以实现字符串到某种类型的转换。Parse的意思是解析。如`int.Parse("10"),DateTime.Parse("2021/10/4T12:35")`等等。